FUNCTION_BLOCK "GCS7_GrpCtrlMain"
TITLE =Group Control UL
//
//COPYRIGHT:   (C) 1997 BY  BUHLER LTD
//                          CH-9240 UZWIL  SWITZERLAND
//
//PRODUCT:     GCS90
//
//TITLE:       FB 009 METHODS  OF  GROUPMANAGEMENT  with 320 groups
//                    Methoden der Gruppenverwaltung
//                    GCPROVB Revision =2
//-------------------------------------------------------------------------
//
//IDENT:        AUTOR:              DEPT:                           DATE:
//
//FB009.4.3     A.Egli              CT3                             23-Nov-2004
//              OutAutostartOkAll
//FB009.4.2     A.Egli              CT3                             14-Mar-2004
//              Reset Idling when group is externel used 
//FB009.4.1     A.Egli              CT3                             04-Mar-2004
//              Autostart: Filter with not ParNotRelForFault and 
//                                         ParNotRelForStarted
//FB009.4.0     A.Egli              CT3                             11-Nov-2003
//              OutAutoStartOkShared
//FB009.3.6     A.Egli              CT3                             14-Okt-2003
//              For available test use InExternal and not InLocked 
//FB009.3.5     A.Egli              CT3                             21-Aug-2003
//              Command OutAnyFault 
//FB009.3.4     A.Egli              CT3                             11-Aug-2003
//              Command CmdManualOffRel: 
//              Send command only to selected group, which OutShared=false
//FB009.3.3     A.Egli              CT3                             22-Jul-2003
//              Condition for All.OutStartWarning 
//FB009.3.2     A.Egli              CT3                             19-Mai-2003
//              OutStartwarning 
//FB009.3.1     A.Egli              CT3                             25-Mar-2003
//              OutPreStarted 
//FB009.3.0     A.Egli              CT3                             23-Sept-2002
//              New Relesae: 
//              OutLoaded;OutDPFault;OutHWStop;OutAutoStartOk; 
//              CmdContinue;InPreStart
//FB009.2.0     A.Egli              CT3                             13-Sept-2000
//              -320 group
//              -Any offset in section DB  
//              -Methode Code=0: Set Pointer 
//FB009.1.7     A.Egli              CT3                             13-Sept-2000
//              OutShared: Wrong pointer (DID with D replaced)
//FB009.1.6     A.Egli              CT3                             06-Jan-99
//              Warning if group with not rel. for fault is in state StFault
//FB009.1.5     A.Egli              CT3                             05-Jan-99
//              Warning if group with not rel. for fault is in state StFault
//FB009.1D      A.Egli              CT3                             20-Aug-99
//              OutFaultAll,FaultReset 
//FB009.1C      A.Egli              CT3                             18-Jul-99
//              OutWarning: Label wrong
//FB009.1B      A.Egli              CT3                             14-Okt-98
//              Reset InPreselected
//FB009.1A      A.Egli              AEE61                           13-Jun-96
//              1st Release
//
//-------------------------------------------------------------------------
//
//PURPOSE:            MANUAL : ....... .DOC
//                    CODE   : FB ...
//
//RESTRICTIONS: GCPROVB Revision >=2
//            
//-------------------------------------------------------------------------
//
//Calling convention:
//==================
//
//Actual open DB = Section DB
//
//Input parameter:
//===============
//CODE:
//  0 - Methode Set Pointer
//  1 - Methode InitPreselection
//  2 - Methode Selection
//  3 - Methode Deselection
//  4 - Methode UpdateCmdSt
//  5 - Methode UpdateEnable
//  6 - Methode UpdateOccupied
//
//Calling order for select of new groups:
//---------------------------------------
//1. Call Methode InitPreselection
//2. ASW: Prepare patter Sec.Gr.InPreselect 
//3. Call Methode Selection
//   ReturnValue: All.OutGrConflict
//4. Call ASW routine 'Select'
{ GCPRO_Revision := '20' }
AUTHOR : EA
FAMILY : GCS7UL
NAME : GRVWMAIN
VERSION : 4.3


VAR_INPUT
  Code : INT ;	//0=Init,1=InitPreselect,2=Select,3=Deselect,4=UpdateCmdSt,5=UpdateEnable
END_VAR
VAR_IN_OUT
  Sec : "GCS7_FB9_Section";	
END_VAR
VAR
  Spare : WORD ;	
  All : STRUCT 	
   CmdClearIdling : BOOL ;	//Stop al groups of this section which are in idling
   OutAutoStartOkShared : BOOL ;	
   InASWFlagAutostart : BOOL ;	//Free for ASW
   OutAutostartOkAll : BOOL ;	//Autostart of all selected groups ok
   Spare04 : BOOL ;	
   Spare05 : BOOL ;	
   OutPreStarted : BOOL ;	
   OutPreStarting : BOOL ;	//Any group is pre-starting
   Spare10 : BOOL ;	
   CmdContinue : BOOL ;	//(*new*)
   CmdManualOffRel : BOOL ;	//(*new*)
   CmdFaultReset : BOOL ;	//Command to fault reset
   CmdManualOff : BOOL ;	//Switch off maunual mode of all object 
   OutStartwarning : BOOL ;	//Any selected group is in startwarning mode
   OutManualAny : BOOL ;	//Any object of this PLC is in manual mode
   InOutASWSelectionOK : BOOL ;	//Used by ASW
   OutSelectionValid : BOOL ;	//Any object is occupied for this section
   CmdNewSelection : BOOL ;	//An new object is occupied
   OutGrConflict : BOOL ;	//An object is not available
   OutGrIsLocked : BOOL ;	//An object is locked by ASW
   OutAutoStartOk : BOOL ;	//(*new*) All relevant Groups are in mode AutoStart
   OutManual : BOOL ;	//Any object of this section is in manual mode
   OutDPFault : BOOL ;	//(*new*)
   OutHWStop : BOOL ;	//(*new*)
   OutStoppedRel : BOOL ;	
   OutStoppedAll : BOOL ;	
   OutLoaded : BOOL ;	//(*new*)
   OutFaultIdling : BOOL ;	
   OutFaultRel : BOOL ;	
   OutFaultAll : BOOL ;	
   OutIdling : BOOL ;	
   OutWarning : BOOL ;	
  END_STRUCT ;	
  Feed : STRUCT 	
   InEnable : BOOL ;	
   Spare01 : BOOL ;	
   CmdNext : BOOL ;	
   Spare03 : BOOL ;	
   Spare04 : BOOL ;	
   Spare05 : BOOL ;	
   Spare06 : BOOL ;	
   Spare07 : BOOL ;	
   OutStoppedRel : BOOL ;	
   OutStoppedAll : BOOL ;	
   OutStartedRel : BOOL ;	
   OutFaultIdling : BOOL ;	
   OutFaultRel : BOOL ;	
   OutFaultAll : BOOL ;	
   OutIdling : BOOL ;	
   OutSelected : BOOL ;	
  END_STRUCT ;	
  Mgr : STRUCT 	
   InEnable : BOOL ;	
   Spare01 : BOOL ;	
   CmdNext : BOOL ;	
   Spare03 : BOOL ;	
   Spare04 : BOOL ;	
   Spare05 : BOOL ;	
   Spare06 : BOOL ;	
   Spare07 : BOOL ;	
   OutStoppedRel : BOOL ;	
   OutStoppedAll : BOOL ;	
   OutStartedRel : BOOL ;	
   OutFaultIdling : BOOL ;	
   OutFaultRel : BOOL ;	
   OutFaultAll : BOOL ;	
   OutIdling : BOOL ;	
   OutSelected : BOOL ;	
  END_STRUCT ;	
  Wgr : STRUCT 	
   InEnable : BOOL ;	
   Spare01 : BOOL ;	
   CmdNext : BOOL ;	
   Spare03 : BOOL ;	
   Spare04 : BOOL ;	
   Spare05 : BOOL ;	
   Spare06 : BOOL ;	
   Spare07 : BOOL ;	
   OutStoppedRel : BOOL ;	
   OutStoppedAll : BOOL ;	
   OutStartedRel : BOOL ;	
   OutFaultIdling : BOOL ;	
   OutFaultRel : BOOL ;	
   OutFaultAll : BOOL ;	
   OutIdling : BOOL ;	
   OutSelected : BOOL ;	
  END_STRUCT ;	
  Ggr : STRUCT 	
   InEnable : BOOL ;	
   Spare01 : BOOL ;	
   CmdNext : BOOL ;	
   Spare03 : BOOL ;	
   Spare04 : BOOL ;	
   Spare05 : BOOL ;	
   Spare06 : BOOL ;	
   Spare07 : BOOL ;	
   OutStoppedRel : BOOL ;	
   OutStoppedAll : BOOL ;	
   OutStartedRel : BOOL ;	
   OutFaultIdling : BOOL ;	
   OutFaultRel : BOOL ;	
   OutFaultAll : BOOL ;	
   OutIdling : BOOL ;	
   OutSelected : BOOL ;	
  END_STRUCT ;	
  InPreselect : ARRAY  [1 .. 320 ] OF BOOL ;	
  OutSelected : ARRAY  [1 .. 320 ] OF BOOL ;	
  OutIdling : ARRAY  [1 .. 320 ] OF BOOL ;	
  ParNotRelForStarted : ARRAY  [1 .. 320 ] OF BOOL  := TRUE;	
  ParNotRelForFault : ARRAY  [1 .. 320 ] OF BOOL  := TRUE;	
  InManual : ARRAY  [1 .. 320 ] OF BOOL  := FALSE;	
  InPreStart : ARRAY  [1 .. 320 ] OF //Input from section: These groups are pre-starting
  BOOL  := FALSE;	
END_VAR
VAR_TEMP
  TmpInOut : STRUCT 	//Methode 4:Temporare copy of input an output of the actual type
   InEnable : BOOL ;	
   Spare01 : BOOL ;	
   CmdNext : BOOL ;	
   Spare03 : BOOL ;	
   Spare04 : BOOL ;	
   InManual : BOOL ;	
   Spare06 : BOOL ;	
   Spare07 : BOOL ;	
   OutStoppedRel : BOOL ;	
   OutStoppedAll : BOOL ;	
   OutStartedRel : BOOL ;	
   OutFaultIdling : BOOL ;	
   OutFaultRel : BOOL ;	
   OutFaultAll : BOOL ;	
   OutIdling : BOOL ;	
   OutSelected : BOOL ;	
  END_STRUCT ;	
  tmpAddrInOut : DINT ;	//Methode 4: Address of TmpInOut
  VarSelGrActType : DWORD ;	//Methode 4: Temporare pattern
  VarSelGrActTypeId : DWORD ;	//Methode 4: Temporare pattern Selected +idling
  tmpValue : DINT ;	
  tmpCntLoopGr : BYTE ;	
  tmpCntLoopType : BYTE ;	
  tmpAddrLoop : DWORD ;	
  tmpAddrSecPreselect : DWORD ;	
  tmpAddrSecSelected : DWORD ;	
  tmpAddrSecIdling : DWORD ;	
  tmpAddrSecManual : DWORD ;	
  tmpAddrSecParRelStarted : DWORD ;	
  tmpAddrSecParRelFault : DWORD ;	
  tmpAddrDB9ParXxx : DWORD ;	//Pointer parameter of group of type xxxx
  tmpAddrDB9ParXxxLoop : DWORD ;	
  tmpAddrSecInPreStart : DWORD ;	
  tmpCODE : INT ;	//FUNC
  SecArray : DINT ;	//Pointer to Array DB9.Section
  SecDB : INT ;	//Actual section DB
  tmpOffsetDI : DINT ;	//Offset Instanz
  tmpCodeIs5 : BOOL ;	//Methode Update Enable
  tmpSecByteNr : DINT ;	
  tmpStoreAR2 : DWORD ;	
  tmpInstanzDB : INT ;	
  tmpNotRelevant : DWORD ;	
  tmpNotRelevantForFault : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =Init Part 1

      L     #Code; 
      T     #tmpCODE; 
      L     P##Sec; 
      LAR1  ; 
//--- Section DB of actual instanz ----------
      L     W [AR1,P#0.0]; 
      T     #SecDB; 
//--- Set Pointer to instanz in section DB ----------
      L     D [AR1,P#2.0]; 
      SLD   8; 
      SRD   11; 
      T     #tmpSecByteNr; 
//------------------------------
      L     #tmpCODE; 
      L     5; // do not init for methode "Update Enable"
      ==I   ; 
      =     #tmpCodeIs5; 
      SPB   InEn; 
//--- Call Section DB ----------
      AUF   DI [#SecDB]; 
      L     #tmpSecByteNr; 
      SLD   3; 
      L     P##Code; 
      +D    ; 
      L     P##All; //) Section DB has only UDT20090
      SLD   8; //) Correction AR2 (10 Byte)
      SRD   8; //)
      -D    ; //)
      LAR2  ; //-->Instanz
InEn: TAR2  #tmpStoreAR2; 

NETWORK
TITLE =Methode "Set Pointer"

//=======================================================================
      AUF   "GCS7_GrCtrlDB"; 
      L     #tmpCODE; 
      L     0; 
      <>I   ; 
      SPB   iEnd; 
//==========================================================
//Check DB9.ParMaxGroupCnt    : must be between 1 and 10
      L     10; 
      L     "GCS7_GrCtrlDB".ParMaxGroupCnt; 
      <I    ; 
      SPB   Stop; 
      L     1; 
      <I    ; 
      SPB   Stop; 
//=======================================================================
//Enter ByteNumber in DB9.Section[x].DBB [<--2.0
      L     "GCS7_GrCtrlDB".ParByteNoSecDB; // ) ParByteArraySectionDB
      SLD   3; 
      LAR1  ; 
iSLo: L     W#16#FFFF; // )=  Sektion-List
      L     DBW [AR1,P#0.0]; // )
      ==I   ; 
      SPB   iAdd; //-->Add pointer, if pointer is not found
      L     DINO; //-->Actual Section-DB
      ==I   ; 
      SPB   iSOt; //-->Enter pointer
      +AR1  P#4.0; 
      SPA   iSLo; 
//=======================================================================
//"Add DB-Pointer"
iAdd: L     #SecDB; //Bit-Number Section Interface
      T     DBW [AR1,P#0.0]; //DB9.Section[n].DBB
      L     W#16#FFFF; 
      T     DBW [AR1,P#4.0]; //DB9.Section[n+1].DBB
//=======================================================================
//"Set Pointer"
iSOt: L     #tmpSecByteNr; //Bit-Number Section Interface
      T     DBW [AR1,P#2.0]; //DB9.Section[x].DBB
      BEA   ; 
//=======================================================================
//!!!!Call Stop, if DB is not found or AR2 < P#DIX2.0   !!!!!!!
//Note: 1. Check DB9.Section[x].DBB    : must be >1
//      2. Check DB9.ParMaxGroupCnt    : must be between 1 and 10

Stop: CALL "SIEMENS_STP" ;
//=======================================================================
iEnd: NOP   0; 

NETWORK
TITLE =Code=1: Methode "InitPreselection"

      L     #tmpCODE; // )
      L     1; // )
      <>I   ; // )
      SPB   aEnd; // )
//-----------------------------------
//Init InPreselect
//Init InPreStart
      LAR1  AR2; 
      L     P##InPreselect; 
      +AR1  ; 
      L     "GCS7_GrCtrlDB".ParMaxGroupCnt; 
F1LE: T     #tmpCntLoopGr; 
// Reset enable bit of selected groups
      L     0; 
      T     DID [AR1,P#0.0]; //  )-> InPreselect
      T     DID [AR1,P#240.0]; //  )-> InPreStart (P#262.0- P#22.0 =+240.0)
      +AR1  P#4.0; 
      L     #tmpCntLoopGr; 
      LOOP  F1LE; 
      SPA   BACK; 
aEnd: NOP   0; 
NETWORK
TITLE = FUNC=2: meth. "selection"

      L     #tmpCODE; 
      L     2; 
      <>I   ; 
      SPB   F2En; 
//--- Available test--------   
      R     #All.OutGrConflict; 
      R     #All.OutGrIsLocked; 
      R     #All.CmdNewSelection; 
      R     #All.OutPreStarting; 
      AUF   "GCS7_GrCtrlDB"; 
      LAR1  P#0.0; // Pointer to DB9
//=======================================================================
// 1. Test New Selection: 
// ---------------------
// 1.0 Set OutPreStarting
// 1.1 Set idling 
// 1.2 Test available
// 1.3 Deleselect Conficted groups 
// 1.4 Deselect not used groups
//=======================================================================
//==Begin Loop Goups A                  ===
      L     "GCS7_GrCtrlDB".ParMaxGroupCnt; 
F2L1: T     #tmpCntLoopGr; 
//--Pointer section
      TAR1  ; 
      TAR2  ; 
      +D    ; 
      T     #tmpOffsetDI; 
      L     P##InPreselect; 
      +D    ; 
      T     #tmpAddrSecPreselect; 
// 
      L     #tmpOffsetDI; 
      L     P##OutSelected; 
      +D    ; 
      T     #tmpAddrSecSelected; 
// 
      L     #tmpOffsetDI; 
      L     P##OutIdling; 
      +D    ; 
      T     #tmpAddrSecIdling; 
// 
      L     #tmpOffsetDI; 
      L     P##InPreStart; 
      +D    ; 
      T     #tmpAddrSecInPreStart; 
// 
// 1.0 Set OutPreStarting -----------
      L     DID [#tmpAddrSecInPreStart]; // Sec.InPreStart
      L     0; 
      <>D   ; 
      S     #All.OutPreStarting; 
// 
// 1.1 Set idling -----------
      L     DID [#tmpAddrSecPreselect]; // Sec.InPreseleced
      INVD  ; 
      L     DID [#tmpAddrSecSelected]; // Sec.OutSelected
      UD    ; //-> not longer used groups
      L     DID [#tmpAddrSecIdling]; // Sec.OutIdling
      OD    ; 
      T     DID [#tmpAddrSecIdling]; // Sec.OutIdling
// 1.2 Test available ----- 
      L     DID [#tmpAddrSecPreselect]; 
      L     DID [#tmpAddrSecSelected]; 
      <>D   ; 
      S     #All.CmdNewSelection; 
      INVD  ; 
      UD    ; // ==> new preseleted groups
      L     DBD [AR1,P#250.0]; // DB9.OutOccupied
      UD    ; // ==> allready used groups
      L     DBD [AR1,P#170.0]; // DB9.ParShare
      INVD  ; 
      UD    ; 
      SPN   F2C1; //-->way conflict
      L     DID [#tmpAddrSecPreselect]; 
      L     DBD [AR1,P#690.0]; // DB9.InExternal  [3.5]
      UD    ; // ==> allready used groups
      L     DBD [AR1,P#170.0]; // DB9.ParShare
      INVD  ; 
      UD    ; 
      SPN   F2C1; //-->way conflict
      L     DID [#tmpAddrSecPreselect]; //                          [3.6]
      L     DBD [AR1,P#650.0]; // DB9.InLocked             [3.6]
      UD    ; // ==> allready used groups [3.6]
      L     DBD [AR1,P#170.0]; // DB9.ParShare             [3.6]
      INVD  ; //                          [3.6]
      UD    ; //                          [3.6]
      SPN   F2C2; 
      SPA   F2Lx; 
//----------------------------------
//Store groups with way conflict
F2C2: SET   ; 
      S     #All.OutGrIsLocked; 
      SPA   F2Lx; 
F2C1: SET   ; 
      S     #All.OutGrConflict; 
      S     #All.CmdNewSelection; 
      T     DBD [AR1,P#970.0]; //  DB9.OutGrConflictObj 
// 
// 1.3 Deleselect Conficted groups 
      INVD  ; 
      L     DID [#tmpAddrSecSelected]; // Sec.OutSelected
      UD    ; 
      T     DID [#tmpAddrSecSelected]; // Sec.OutSelected
// Store DB
      L     DINO; 
      T     "GCS7_GrCtrlDB".OutConflictSecDB; //DB9.OutConflictSecDB
// 
//----------------------------------
// 1.4 Deselect not used groups
F2Lx: L     DID [#tmpAddrSecPreselect]; // Sec.InPreseleced
      L     DID [#tmpAddrSecSelected]; // Sec.OutSelected
      UD    ; 
      T     DID [#tmpAddrSecSelected]; // Sec.OutSelected
//----------------------------------
      +AR1  P#4.0; //->(next 32 groups)
      L     #tmpCntLoopGr; 
      LOOP  F2L1; 

//=End Loop Goups A                     === 
//=========================================

//=======================================================================
// 2. Copy Preselected   --> Selected  
//=======================================================================

//Select new groups
      U     #All.OutGrConflict; 
      ON    #All.CmdNewSelection; 
      SPB   F2X2; 
//--Begin Loop Groups B
      LAR1  AR2; 
      L     "GCS7_GrCtrlDB".ParMaxGroupCnt; 
F2L2: T     #tmpCntLoopGr; 
//-Pointer
      TAR1  ; 
      L     P##InPreselect; 
      +D    ; 
      T     #tmpAddrSecPreselect; 
      TAR1  ; 
      L     P##OutSelected; 
      +D    ; 
      T     #tmpAddrSecSelected; 
//--Copy Preselected   --> Selected  
      L     DID [#tmpAddrSecPreselect]; // Sec.InPreseleced
      T     DID [#tmpAddrSecSelected]; // Sec.OutSelected
//--Next 32 groups 
      +AR1  P#4.0; 
      L     #tmpCntLoopGr; 
      LOOP  F2L2; 
//--End Loop Groups B
//---------------------------------
F2X2: UN    #All.OutGrConflict; 
      UN    #All.OutSelectionValid; 
      S     #All.OutSelectionValid; 
      SPB   F5; //--> Call Methode 6 "Update Occupied"
//=========================================
      U     #All.CmdNewSelection; 
      SPB   F5; //--> Call Methode 6 "Update Occupied"
      SPA   BACK; 
F2En: NOP   0; 
NETWORK
TITLE = FUNC=3: meth. "Deselection all"

      L     #tmpCODE; 
      L     3; 
      <>I   ; 
      SPB   F3En; 
      R     #All.OutGrConflict; 
      R     #All.OutGrIsLocked; 
      R     #All.CmdNewSelection; 

//!!! Do only operate, if OutSelectionValid=true
      UN    #All.OutSelectionValid; 
      SPB   BACK; 
      R     #All.OutSelectionValid; 
//________________________________________
// -Copy Selected --> Idling  
// Begin Loop A
      LAR1  AR2; 
      L     "GCS7_GrCtrlDB".ParMaxGroupCnt; 
F3Lo: T     #tmpCntLoopGr; 
//-Pointer
      TAR1  ; 
      L     P##InPreselect; 
      +D    ; 
      T     #tmpAddrSecPreselect; 
// 
      TAR1  ; 
      L     P##OutSelected; 
      +D    ; 
      T     #tmpAddrSecSelected; 
// 
      TAR1  ; 
      L     P##OutIdling; 
      +D    ; 
      T     #tmpAddrSecIdling; 
// 
      L     DID [#tmpAddrSecSelected]; // Sec.OutSelected
      L     DID [#tmpAddrSecIdling]; // Sec.OutIdling
      OD    ; 
      T     DID [#tmpAddrSecIdling]; // Sec.OutIdling
      L     0; //    
      T     DID [#tmpAddrSecPreselect]; // Sec.InPreseleced
      T     DID [#tmpAddrSecSelected]; // Sec.OutSelected
      +AR1  P#4.0; //-> Next DD in section DB (next 32 groups) 
      L     #tmpCntLoopGr; 
      LOOP  F3Lo; 
// END Loop A
//   --Update DB9: Occupied -----
      SPA   F5; // Call Methode UpdateOcupied
F3En: NOP   0; 
NETWORK
TITLE = CODE=5: Methode "UpdateEnable", CODE=6"Update Occupied"
//Update DB9.OutEnable
//Update DB9.OutManual
//Update DB9.OutOccupied
//Update DB9.OutShared
//
//Is called aloso by methode 2: "Select" 
//Is called aloso by methode 3: "Deselect All" 
//
      L     #tmpCODE; 
      L     5; //Methode UpdateEnable
      ==I   ; 
      SPB   F5; 
      L     #tmpCODE; 
      L     6; //Methode UpdateOccupied
      ==I   ; 
      SPB   F5; 
      SPA   F5En; 
F5:   AUF   "GCS7_GrCtrlDB"; 
//=== Loop section ===========
      LAR1  P#DBX 0.0; // Pointer to DB9
      L     "GCS7_GrCtrlDB".ParMaxGroupCnt; 
F5L1: T     #tmpCntLoopGr; 
// Reset enable bit of selected groups
      UN    #tmpCodeIs5; 
      SPB   F5J0; 
      L     DBD [AR1,P#290.0]; // DB9.OutEnable 
      L     DBD [AR1,P#250.0]; // DB9.OutCccupied
      INVD  ; 
      UD    ; 
      T     DBD [AR1,P#290.0]; // DB9.OutEnable 
// Reset occupied bit
F5J0: L     0; // 
      T     DBD [AR1,P#210.0]; // DB9.OutShared
      T     DBD [AR1,P#250.0]; // DB9.Occupied
//Next group
      +AR1  P#4.0; 
      L     #tmpCntLoopGr; 
      LOOP  F5L1; 
//============================================
//Loop Section 
//============================================
      L     "GCS7_GrCtrlDB".ParByteNoSecDB; // ) ParByteArraySectionDB
      SLD   3; 
F5LS: T     #SecArray; 
      L     W#16#FFFF; // )=  Sektion-List
      L     DBW [#SecArray]; // DB9.Section[x].DBNr
      T     #tmpInstanzDB; //-> Actual Section-DB
      ==I   ; 
      SPB   F5OT; //-->Out
      L     0; 
      ==I   ; 
      SPB   F5NS; //--> Next section
      AUF   DI [#tmpInstanzDB]; //-->Pointer to instance in section
      LAR1  #SecArray; 
      L     DBW [AR1,P#2.0]; //  DB9.Section[x].DBB
      SLD   3; 
      L     P##Code; 
      +D    ; 
      L     P##All; //) Section DB has only UDT20090
      SLD   8; //) Correction AR2 (10 Byte)
      SRD   8; //)
      -D    ; //)
      LAR2  ; //-->Pointer to instance in section
      LAR1  P#DBX 0.0; // Pointer to DB9
//------------------------------------------
//Operate section x 
//------------------------------------------
      UN    #All.OutSelectionValid; // )OutSelectionValid
      SPB   F5NS; // )
//-- Loop groups 
      L     "GCS7_GrCtrlDB".ParMaxGroupCnt; 
F5LG: T     #tmpCntLoopGr; 
// Pointer 
      TAR2  ; 
      TAR1  ; 
      +D    ; 
      L     P##OutSelected; 
      +D    ; 
      T     #tmpAddrSecSelected; 
// -- Occupied --
      L     DID [#tmpAddrSecSelected]; //  Sec.OutSelected
      L     DBD [AR1,P#250.0]; //  DB9.OutOccupied [1.7]
      UD    ; 
      L     DBD [AR1,P#210.0]; //  DB9.OutShared
      OD    ; 
      T     DBD [AR1,P#210.0]; //  DB9.OutShared
      L     DID [#tmpAddrSecSelected]; //  Sec.OutSelected
      L     DBD [AR1,P#250.0]; //  DB9.OutOccupied
      OD    ; 
      T     DBD [AR1,P#250.0]; //->DB9.OutOccupied
//=== Enable ==============
      UN    #tmpCodeIs5; 
      SPB   F5XG; 
// -- Enable Feed--
      UN    #Feed.InEnable; // )Sec.Feed.InEnable
      SPB   F5mg; // )
      L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected
      L     DBD [AR1,P#10.0]; // )DB9.ParFeed
      UD    ; // )
      L     DBD [AR1,P#290.0]; // )DB9.OutEnable 
      OD    ; // )(Set Enable)
      T     DBD [AR1,P#290.0]; // )DB9.OutEnable 
// -- Enable Mgr--
F5mg: UN    #Mgr.InEnable; // )Sec.Mgr.InEnable
      SPB   F5wg; // )
      L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected
      L     DBD [AR1,P#50.0]; // )DB9.ParMgr
      UD    ; // )
      L     DBD [AR1,P#290.0]; // )DB9.OutEnable 
      OD    ; // )(Set Enable)
      T     DBD [AR1,P#290.0]; // )DB9.OutEnable 
// -- Enable Wgr--
F5wg: UN    #Wgr.InEnable; // )Sec.Wgr.InEnable
      SPB   F5gg; // )
      L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected
      L     DBD [AR1,P#90.0]; // )DB9.ParWgr
      UD    ; // )
      L     DBD [AR1,P#290.0]; // )DB9.OutEnable 
      OD    ; // )(Set Enable)
      T     DBD [AR1,P#290.0]; // )DB9.OutEnable 
// -- Enable GGr--
F5gg: UN    #Ggr.InEnable; // )Sec.Ggr.InEnable
      SPB   F5XG; // )
      L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected
      L     DBD [AR1,P#130.0]; // )DB9.ParGgr
      UD    ; // )
      L     DBD [AR1,P#290.0]; // )DB9.OutEnable 
      OD    ; // )(Set Enable)
      T     DBD [AR1,P#290.0]; // )DB9.OutEnable 
F5XG: +AR1  P#4.0; 
      L     #tmpCntLoopGr; 
      LOOP  F5LG; 
//=== End Loop groups ==
F5NS: L     #SecArray; 
      L     P#4.0; 
      +D    ; // Pointer to next section
      SPA   F5LS; 
F5OT: AUF   DI [#SecDB]; 
      LAR2  #tmpStoreAR2; 
F5En: NOP   0; 
NETWORK
TITLE = FUNC=4: meth. "UpdateCmdSt"
//- Update Sec.OutIdling[c]
//- Update Sec.xxx.OutIdling
//- Update Sec.xxx.OutSelected
//- Update State
//- Send Command to DB9
//Implementation: 
//--------------
//1.Part: Summery commands and state of all groups
//2.Part: State and commands of one type:
//  Because the function of Feed, Mgr, Wgr and GGr are nearly equal we use the 
//same code for all.
//  For this reason this segment is processed in a loop (5 times).
//  Loop 1: Feed
//  Loop 2: Mgr
//  Loop 3: Wgr
//  Loop 4: GGr
//
      L     #tmpCODE; 
      L     4; 
      ==I   ; 
      SPB   F4; 
      L     #tmpCODE; 
      L     2; 
      ==I   ; 
      SPB   F4; 
      SPA   BACK; 
F4:   R     #All.OutFaultIdling; //-> Sec.All.OutIdlingFault
      R     #All.OutWarning; //-> Sec.All.OutWarning
      R     #All.OutManual; //-> Sec.All.OutManual
      R     #All.OutManualAny; //-> Sec.All.OutManualAny
      R     #All.OutLoaded; //[3.0]
      R     #All.OutDPFault; //[3.0]
      R     #All.OutHWStop; // [3.0]
      S     #All.OutAutoStartOk; // [3.0]
      S     #All.OutAutoStartOkShared; // [4.0]
      S     #All.OutAutostartOkAll; // [4.3]
      S     #All.OutPreStarted; //[3.0]
      R     #All.OutStartwarning; // [3.0]
      R     "GCS7_GrCtrlDB".OutManualAny; // [3.0]
      R     "GCS7_GrCtrlDB".OutFaultAny; // [3.0]

//==Begin Loop Groups "summary" ===============================
      LAR1  P#0.0; // Pointer to DB9.DX0.0
      L     "GCS7_GrCtrlDB".ParMaxGroupCnt; 
F4L1: T     #tmpCntLoopGr; //-->Loop counter groups
//---Pointer to section ---------------------------------------
      TAR1  ; 
      TAR2  ; 
      +D    ; 
      T     #tmpOffsetDI; 
      L     P##OutIdling; 
      +D    ; 
      T     #tmpAddrSecIdling; 
      L     #tmpOffsetDI; 
      L     P##OutSelected; 
      +D    ; 
      T     #tmpAddrSecSelected; 
      L     #tmpOffsetDI; 
      L     P##ParNotRelForFault; 
      +D    ; 
      T     #tmpAddrSecParRelFault; 
      L     #tmpOffsetDI; 
      L     P##ParNotRelForStarted; 
      +D    ; 
      T     #tmpAddrSecParRelStarted; //[3.1]
      L     #tmpOffsetDI; 
      L     P##InManual; 
      +D    ; 
      T     #tmpAddrSecManual; 
      L     #tmpOffsetDI; 
      L     P##InPreStart; 
      +D    ; 
      T     #tmpAddrSecInPreStart; 
      L     DID [#tmpAddrSecInPreStart]; 
      L     DID [#tmpAddrSecParRelFault]; // )Sec.ParRelForFault
      OD    ; 
      T     #tmpNotRelevantForFault; 
//-- OutIdling --------------------------------------------
      L     DBD [AR1,P#250.0]; // ) DB9.OutOccupied
      L     DBD [AR1,P#690.0]; // ) DB9.InExternal             //[4.2]
      OD    ; 
      L     DBD [AR1,P#450.0]; // ) DB9.InStopped
      OD    ; // ) OR
      INVD  ; // ) NOT
      L     DID [#tmpAddrSecIdling]; // ) Sec.OutIdling
      UD    ; // )
      T     DID [#tmpAddrSecIdling]; // ) Sec.OutIdling
//--CmdContinue------------------------------------------- 
      UN    #All.CmdContinue; // )Sec.CmdContinue [3.0]
      SPB   F4CU; // )                [3.0]
      L     DBD [AR1,P#730.0]; // )DB9.CmdContinue [3.0]
      L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected [3.0]    
      OD    ; // )                [3.0]
      T     DBD [AR1,P#730.0]; // )DB9.CmdContinue [3.0]
//--CmdManualOff------------------------------------------- 
F4CU: UN    #All.CmdManualOff; // Sec.CmdManualOff
      SPB   F4C2; // 
      L     DBD [AR1,P#410.0]; // DB9.OutManualOff
      L     DID [#tmpAddrSecManual]; // Sec.InManual
      OD    ; // 
      T     DBD [AR1,P#410.0]; // DB9.OutManualOff
//--CmdManualOff Relevant------------------------------------------- 
F4C2: UN    #All.CmdManualOffRel; // Sec.CmdManualOff           //[3.4]
      SPB   F4Fr; //                            //[3.4]
      L     DBD [AR1,P#250.0]; // DB9.OutOccupied            //[3.4]  
      INVD  ; // NOT                        //[3.4]  
      L     DID [#tmpAddrSecSelected]; // Sec.OutSelected            //[3.4]      
      OD    ; //                            //[3.4]  
      L     DID [#tmpAddrSecManual]; // Sec.InManual               //[3.4]  
      UD    ; //                            //[3.4]  
      T     #tmpValue; // ==> not relevant group 
      L     DBD [AR1,P#690.0]; // DB9.InExternal             //[3.4]
      L     DBD [AR1,P#210.0]; // DB9.OutShared              //[3.4]
      OD    ; //                            //[3.4]  
      INVD  ; //                            //[3.4]  
      L     #tmpValue; // not relevant group         //[3.4]  
      UD    ; //                            //[3.4]  
      L     DBD [AR1,P#410.0]; // DB9.OutManualOff           //[3.4]  
      OD    ; //                            //[3.4]  
      T     DBD [AR1,P#410.0]; // DB9.OutManualOff           //[3.4]  
//--CmdFaultReset------------------------------------------- 
F4Fr: UN    #All.CmdFaultReset; // )Sec.CmdFaultReset
      SPB   F4CI; 
      L     DBD [AR1,P#250.0]; // ) DB9.OutOccupied    [1D]
      INVD  ; // ) NOT                [1D]
      L     DID [#tmpAddrSecManual]; // )Sec.InManualGr      [1D]
      UD    ; // )                    [1D]
      L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected     
      OD    ; 
      L     DBD [AR1,P#370.0]; // )DB9.CmdFaultReset
      OD    ; // )
      T     DBD [AR1,P#370.0]; // )DB9.CmdFaultReset
//--- Clear idling ---------------------
F4CI: UN    #All.CmdClearIdling; // )Sec.ClearIdling
      SPB   F4MO; // )
      L     DID [#tmpAddrSecIdling]; // )Sec.OutIdling
      INVD  ; // )
      L     DBD [AR1,P#290.0]; // )DB9.OutEnable
      UD    ; // )(Reset)
      T     DBD [AR1,P#290.0]; // )DB9.OutEnable
//--OutManual---    
F4MO: L     0; 
      L     DBD [AR1,P#610.0]; // DB9.InManual
      <>D   ; 
      S     #All.OutManualAny; // 
      S     "GCS7_GrCtrlDB".OutManualAny; // [3.0]
      SET   ; // VKE must be 1 for all SPZ
      L     DID [#tmpAddrSecManual]; // Sec.InManualGr
      UD    ; // 
      SPZ   F4Wa; // [1C]
      S     #All.OutManual; //->
//--Warning---    
F4Wa: L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected  [1C]
      L     DBD [AR1,P#570.0]; // )DB9.InWarning
      UD    ; // )
      SPZ   F4WO; // )
      S     #All.OutWarning; //->
//Waning if not rel for fault [Start rel 1.5]
F4WO: L     DID [#tmpAddrSecSelected]; // Sec.OutSelected  
      L     #tmpNotRelevantForFault; // Sec.ParNotRelForFault /PreStart
      UD    ; // )
      L     DBD [AR1,P#530.0]; // )DB9.InFault
      UD    ; // )
      SPZ   F4FI; // )
      S     #All.OutWarning; //-> [end rel. 1.5]
// --FaultAny    
F4FI: L     0; 
      L     DBD [AR1,P#530.0]; // )DB9.InFault
      <>D   ; 
      S     "GCS7_GrCtrlDB".OutFaultAny; // [3.0]
// --FaultIdling    
      L     DID [#tmpAddrSecIdling]; // )Sec.OutIdling
      L     DBD [AR1,P#530.0]; // )DB9.InFault
      UD    ; // )
      SPZ   F4X1; // )
      SET   ; 
      S     #All.OutFaultIdling; //-->Sec.All.OutFaultIdling
//--OutLoaded---    
F4X1: L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected  [3.0]
      L     DBD [AR1,P#770.0]; // )DB9.OutLoaded    [3.0]
      UD    ; // )                 [3.0]
      SPZ   F4LD; // )                 [3.0]
      SET   ; 
      S     #All.OutLoaded; //->                 [3.0]
//--OutDPFault---    
F4LD: L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected  [3.0]
      L     DBD [AR1,P#810.0]; // )DB9.OutDPFault   [3.0]
      UD    ; // )                 [3.0]
      SPZ   F4DP; // )                 [3.0]
      SET   ; 
      S     #All.OutDPFault; //->                 [3.0]
//--OutHWStop---    
F4DP: L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected  [3.0]
      L     DBD [AR1,P#850.0]; // )DB9.OutHWStop    [3.0]
      UD    ; // )                 [3.0]
      SPZ   F4HS; // )                 [3.0]
      SET   ; 
      S     #All.OutHWStop; //->                 [3.0]
//--OutAutoStartOk---    
F4HS: L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected  [3.0]
      L     DID [#tmpAddrSecParRelStarted]; // ParNotRelForStarted [4.1]
      INVD  ; //                    [4.1]
      UD    ; //                    [4.1]
      L     #tmpNotRelevantForFault; // Sec.ParRelForFault [4.1] 
      INVD  ; //                    [4.1]
      UD    ; //                    [4.1]
      L     DBD [AR1,P#890.0]; // )DB9.OutAutoStart [3.0]
      INVD  ; // )                 [3.0]
      UD    ; // )                 [3.0]
      SPZ   F4A2; // )                 [3.0]
      SET   ; 
      R     #All.OutAutoStartOk; //->                 [3.0]
//--OutAutoStartSharedOk---    
F4A2: L     DBD [AR1,P#690.0]; // DB9.InExternal    [4.0]
      L     DBD [AR1,P#210.0]; // DB9.OutShared     [4.0]
      OD    ; //                   [4.0]
      L     DID [#tmpAddrSecParRelStarted]; // ParNotRelForStarted [4.1]
      OD    ; //                    [4.1]
      L     #tmpNotRelevantForFault; // Sec.ParRelForFault [4.1] 
      OD    ; //                    [4.1] 
      L     DID [#tmpAddrSecSelected]; // Sec.OutSelected   [4.0]
      UD    ; //                   [4.0]
      L     DBD [AR1,P#890.0]; // DB9.OutAutoStart  [4.0]
      INVD  ; //                   [4.0]
      UD    ; //                   [4.0]
      SPZ   F4SW; //                   [4.0]
      SET   ; //                   [4.0]
      R     #All.OutAutoStartOkShared; //->                 [4.0]
//--OutAutoStartOkAll---    
F4SW: L     DID [#tmpAddrSecSelected]; // Sec.OutSelected   [4.3]
      L     DBD [AR1,P#890.0]; // DB9.OutAutoStart  [4.3]
      INVD  ; //                   [4.3]
      UD    ; //                   [4.3]
      SPZ   F4AA; //                   [4.3]
      SET   ; //                   [4.3]
      R     #All.OutAutostartOkAll; //->                 [4.3]
//--OutStartwarning---    
F4AA: L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected     [3.0]
      L     DBD [AR1,P#930.0]; // )DB9.OutStartwarning [3.0]
//[3.3]      INVD                              // )                    [3.0]
      UD    ; // )                    [3.0]
      SPZ   F4AS; // )                    [3.0]
      SET   ; 
      S     #All.OutStartwarning; //->                 [3.0]
//------------------------------------------------------ 
//  --PreStarted                                      -----
F4AS: L     DBD [AR1,P#490.0]; // DB9.InStarted
      INVD  ; 
      L     DID [#tmpAddrSecInPreStart]; // InPreStart
      UD    ; 
      L     DID [#tmpAddrSecParRelStarted]; // ParNotRelForStarted
      INVD  ; 
      UD    ; // 
      SPZ   F4SS; // 
      SET   ; 
      R     #All.OutPreStarted; 
F4SS: +AR1  P#4.0; //-> Next DD in DB9    (next 32 groups)
      L     #tmpCntLoopGr; 
      LOOP  F4L1; 
//==End Loop Groups "summary" =====================================

//=================================================================
// 4 Loops (FEED, MGR, WGR, GGR)
//=================================================================
// CntLoopTyp=0 : FEED
// CntLoopTyp=1 : MGR
// CntLoopTyp=2 : WGR
// CntLoopTyp=3 : GGR
// 
// Note:  'InOut' of the actual typeis copied to TmpInOut 

      L     P##TmpInOut; 
      T     #tmpAddrInOut; 
      L     0; 
F4L2: T     #tmpCntLoopType; 
      SPL   H5xx; 
      SPA   HFe1; 
      SPA   HMg1; 
      SPA   HWg1; 
      SPA   HGg1; 
H5xx: SPA   HSav; //-->Last type
//---- Copy Feed to Buffer ----------------
HFe1: L     P##Feed; 
      TAR2  ; 
      +D    ; 
      T     #tmpAddrLoop; 
      L     DIW [#tmpAddrLoop]; // Sec.Feed.InOut
      T     LW [#tmpAddrInOut]; // Buffer TmpInOut
      L     P#DBX 10.0; // DB9.ParFeed
      T     #tmpAddrDB9ParXxx; 
      SPA   HCmd; //--> Start 
//--- Store Buffer to Feed -----------------
HMg1: L     LW [#tmpAddrInOut]; //  Buffer TmpInOut
      T     DIW [#tmpAddrLoop]; //->Sec.Feed.InOut
//    Copy Mgr to Buffer
      L     P##Mgr; 
      TAR2  ; 
      +D    ; 
      T     #tmpAddrLoop; 
      L     DIW [#tmpAddrLoop]; //  Sec.Mgr.InOut
      T     LW [#tmpAddrInOut]; //  Buffer TmpInOut
      L     P#50.0; //  DB9.ParMgr
      T     #tmpAddrDB9ParXxx; 
      SPA   HCmd; //--> Start 
//--- Store Buffer to MGR -------------------
HWg1: L     LW [#tmpAddrInOut]; //CopyInOut
      T     DIW [#tmpAddrLoop]; //->Sec.Mgr.InOut
//--- Copy Wgr to Buffer
      L     P##Wgr; 
      TAR2  ; 
      +D    ; 
      T     #tmpAddrLoop; 
      L     DIW [#tmpAddrLoop]; //  Sec.Wgr.InOut
      T     LW [#tmpAddrInOut]; //  Buffer TmpInOut
      L     P#DBX 90.0; //  DB9.ParWgr
      T     #tmpAddrDB9ParXxx; 
      SPA   HCmd; //--> Start 
//--- Store Buffer to Wgr -------------------
HGg1: L     LW [#tmpAddrInOut]; //  Buffer TmpInOut
      T     DIW [#tmpAddrLoop]; //->Sec.Wgr.InOut
//--- Copy Ggr to Buffer --------------------
      L     P##Ggr; 
      TAR2  ; 
      +D    ; 
      T     #tmpAddrLoop; 
      L     DIW [#tmpAddrLoop]; //  Sec.Ggr.InOut
      T     LW [#tmpAddrInOut]; //  CopyInOut
      L     P#DBX 130.0; //  DB9.ParGgr
      T     #tmpAddrDB9ParXxx; 
      SPA   HCmd; //--> Start 
//--- Store Buffer to Ggr -------------------
HSav: L     LW [#tmpAddrInOut]; //CopyInOut
      T     DIW [#tmpAddrLoop]; //->Sec.Ggr.InOut
      SPA   HOut; 
//======================================================
//==Begin Loop groups                             ====== 
HCmd: LAR1  P#0.0; // Pointer to DB9.DX0.0
      SET   ; 
      S     #TmpInOut.OutStoppedRel; 
      S     #TmpInOut.OutStoppedAll; 
      S     #TmpInOut.OutStartedRel; 
      R     #TmpInOut.OutFaultRel; 
      R     #TmpInOut.OutFaultAll; 
      R     #TmpInOut.OutIdling; 
      R     #TmpInOut.OutSelected; 
      L     "GCS7_GrCtrlDB".ParMaxGroupCnt; 
HLo2: T     #tmpCntLoopGr; // ) Loop Counter
//---------------------------
//Pointer to section 
      TAR1  ; 
      TAR2  ; 
      +D    ; 
      T     #tmpOffsetDI; 
      L     P##ParNotRelForStarted; 
      +D    ; 
      T     #tmpAddrSecParRelStarted; 

      L     #tmpOffsetDI; 
      L     P##ParNotRelForFault; 
      +D    ; 
      T     #tmpAddrSecParRelFault; 

      L     #tmpOffsetDI; 
      L     P##InPreStart; 
      +D    ; 
      T     #tmpAddrSecInPreStart; 

      L     #tmpOffsetDI; 
      L     P##OutIdling; 
      +D    ; 
      T     #tmpAddrSecIdling; 

      L     #tmpOffsetDI; 
      L     P##OutSelected; 
      +D    ; 
      T     #tmpAddrSecSelected; 

      TAR1  ; 
      L     #tmpAddrDB9ParXxx; 
      +D    ; 
      T     #tmpAddrDB9ParXxxLoop; 

      L     DID [#tmpAddrSecInPreStart]; 
      L     DID [#tmpAddrSecParRelFault]; // )Sec.ParRelForFault
      OD    ; 
      T     #tmpNotRelevantForFault; 
//-- Selected 
      L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected
      L     DID [#tmpAddrSecIdling]; // )Sec.OutIdling
      OD    ; 
      L     DBD [#tmpAddrDB9ParXxxLoop]; // 
      UD    ; // )
      T     #VarSelGrActTypeId; //->selected+idling group of this type
      L     DBD [#tmpAddrDB9ParXxxLoop]; // 
      L     DID [#tmpAddrSecSelected]; // )Sec.OutSelected
      UD    ; // )
      T     #VarSelGrActType; //->selected group of this type
      SPZ   HF1; 
      S     #TmpInOut.OutSelected; // )--> Sec.Feed.OutSelected
//------------------------------------------------------ 
//-- Selected / Idling                             -----
HF1:  L     DID [#tmpAddrSecIdling]; // ) Sec.OutIdling
      L     DBD [AR1,P#10.0]; // ) DB9.ParFeed
      UD    ; // )
      SPZ   HNx; 
      S     #TmpInOut.OutIdling; // )--> Sec.Feed.OutIdling
//------------------------------------------------------ 
//--CmdNext                                        ----- 
HNx:  UN    #TmpInOut.CmdNext; // )Sec.xxx.CmdNext
      SPB   HFa; 
      L     #VarSelGrActType; //->selected group of this type
      L     DBD [AR1,P#330.0]; // )DB9.CmdNext
      OD    ; // )
      T     DBD [AR1,P#330.0]; // )DB9.CmdNext
//------------------------------------------------------ 
//  --FaultRel                                     -----
HFa:  L     #VarSelGrActType; //->selected group of this type
      L     DBD [AR1,P#530.0]; // )DB9.InFault
      UD    ; // )
      SPZ   HSp; // )
      S     #TmpInOut.OutFaultAll; //-->Sec.xxx.FeedAny
      L     #tmpNotRelevantForFault; // )Sec.ParRelForFault
      INVD  ; 
      UD    ; // )
      SPZ   HSp; // )
      S     #TmpInOut.OutFaultRel; //-->Sec.xxx.FeedRel
//------------------------------------------------------ 
//  --Stopped                                      -----
HSp:  L     DBD [AR1,P#450.0]; // DB9.InStopped
      INVD  ; // 
      L     #VarSelGrActTypeId; // selected group of this type
      UD    ; // 
      SPZ   HSt; 
      T     #tmpValue; // ==> not stopped groups 
      R     #TmpInOut.OutStoppedAll; //-->Sec.xxx.StoppedAll
      L     DBD [AR1,P#690.0]; // DB9.InExternal [2.0]
      L     DBD [AR1,P#210.0]; // DB9.OutShared
      OD    ; 
      INVD  ; 
      L     #tmpValue; // <== not stopped groups 
      UD    ; 
      SPZ   HSt; 
      R     #TmpInOut.OutStoppedRel; //-->Sec.xxx.StoppedRel
//------------------------------------------------------ 
//  --Started                                      -----
HSt:  L     DID [#tmpAddrSecParRelStarted]; // ParRelForStarted
      L     DID [#tmpAddrSecInPreStart]; // InPreStart
      OD    ; 
      T     #tmpNotRelevant; 
      L     DBD [AR1,P#490.0]; // DB9.InStarted
      INVD  ; 
      L     #VarSelGrActType; // selected group of this type
      UD    ; 
      L     #tmpNotRelevant; 
      INVD  ; 
      UD    ; // 
      SPZ   HStx; // 
      R     #TmpInOut.OutStartedRel; //-->Sec.xxx.Started
HStx: +AR1  P#4.0; //-> Next DD in DB9    (next 32 groups)
      L     #tmpCntLoopGr; 
      LOOP  HLo2; //--> Next group commands (+4Byte)
//==End loop groups                       ==============
//======================================================
      SET   ; 
      R     #TmpInOut.CmdNext; // )Sec.xxx.CmdNext
      L     #tmpCntLoopType; 
      +     1; 
      SPA   F4L2; 
//========================================================================
// END Loops (FEED, MGR, WGR, GGR)
//=========================================================================
HOut: NOP   0; 
      U     #Feed.OutStoppedRel; 
      U     #Mgr.OutStoppedRel; 
      U     #Wgr.OutStoppedRel; 
      =     #All.OutStoppedRel; 

      U     #Feed.OutStoppedAll; 
      U     #Mgr.OutStoppedAll; 
      U     #Wgr.OutStoppedAll; 
      =     #All.OutStoppedAll; 

      U     #Feed.OutFaultRel; 
      O     #Mgr.OutFaultRel; 
      O     #Wgr.OutFaultRel; 
      O     #Ggr.OutFaultRel; 
      =     #All.OutFaultRel; 

      U     #Feed.OutFaultAll; 
      O     #Mgr.OutFaultAll; 
      O     #Wgr.OutFaultAll; 
      O     #Ggr.OutFaultAll; 
      =     #All.OutFaultAll; // [1D]

      U     #Feed.OutIdling; 
      O     #Mgr.OutIdling; 
      O     #Wgr.OutIdling; 
      O     #Ggr.OutIdling; 
      =     #All.OutIdling; 
      SET   ; 
      R     #All.CmdFaultReset; 
      R     #All.CmdManualOff; 
      R     #All.CmdManualOffRel; //[3.4]
      R     #All.CmdFaultReset; 
      R     #All.CmdClearIdling; 
      R     #All.CmdContinue; // [3.0]

NETWORK
TITLE = END
//
//
BACK: NOP   0; 

END_FUNCTION_BLOCK

